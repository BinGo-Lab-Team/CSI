pragma ComponentBehavior: Bound
import QtQuick
import QtQuick.Controls
import QtQuick.Layouts
import QtMultimedia

ApplicationWindow {
    id: win
    visible: true
    width: 960
    height: 640
    title: win.tr("csi.title", "CSI")
    color: "transparent"
    flags: Qt.Window | Qt.FramelessWindowHint

    // ===== 配置 =====
    readonly property bool maximized: visibility === Window.Maximized
    readonly property bool squareCorners: (visibility === Window.FullScreen) || (visibility === Window.Maximized)
    property int currentTab: 0
    property int cornerRadius: 12
    property int inset: 18

    readonly property int durFast: 80
    readonly property int durMed: 120
    readonly property int durSlow: 160
    readonly property int debounceMs: 200
    property double _lastToggleTS: 0
    function _now() { return Date.now() }
    function _debouncedToggleMaxRestore() {
        var t = _now();
        if (t - _lastToggleTS < debounceMs) return;
        _lastToggleTS = t;
        maximized ? win.showNormal() : win.showMaximized();
    }

    readonly property real dpr: Screen.devicePixelRatio
    readonly property int hit: Math.round(6 * dpr)
    readonly property int cornerHit: Math.round(10 * dpr)

    property bool enableStartupSound: true
    MediaPlayer {
        id: startupPlayer
        source: "qrc:/res/audio/startup.wav"
        audioOutput: AudioOutput { id: out; volume: 1.0; muted: false }
        Component.onCompleted: Qt.callLater(() => { if (win.enableStartupSound) play() })
        onErrorOccurred: (error, errorString) => {
            console.warn("[MediaPlayer] error:", error, errorString)
            win.enableStartupSound = false
        }
    }

    // 主题
    Theme { id: theme }
    property color menuGradTop: theme.menuGradTop
    property color menuGradMid: theme.menuGradMid
    property color menuGradBot: theme.menuGradBot
    property color menuTextColor: theme.menuTextColor
    property color hoverMask: theme.hoverMask
    readonly property color invertBase: menuTextColor

    function tr(id, fallback) {
        var s = qsTrId(id);
        return (s === id || s === "") ? fallback : s;
    }

    // 快捷键
    Shortcut { sequences: [ StandardKey.Close ]; onActivated: win.close() }
    Shortcut { sequences: [ "Alt+F10" ]; onActivated: win._debouncedToggleMaxRestore() }
    Shortcut { sequences: [ "F11" ]; onActivated: win.visibility = (win.visibility === Window.FullScreen) ? Window.AutomaticVisibility : Window.FullScreen }
    Shortcut { sequences: [ "Escape" ]; onActivated: if (win.visibility === Window.FullScreen) win.showNormal() }
    Shortcut { sequences: [ "Ctrl+1" ]; onActivated: win.currentTab = 0 }
    Shortcut { sequences: [ "Ctrl+2" ]; onActivated: win.currentTab = 1 }

    ShadowFrame {
        id: shell
        anchors.fill: parent
        inset: win.squareCorners ? 0 : win.inset
        cornerRadius: win.cornerRadius
        squareCorners: win.squareCorners
        frameColor: win.palette.window

        // 关键：外层圆角启用 MSAA，保证窗口轮廓平滑
        layer.enabled: true
        layer.samples: 4
        layer.smooth: true

        // ===== 标题栏 =====
        Rectangle {
            id: titleBar
            height: 56
            anchors.left: parent.left
            anchors.right: parent.right
            anchors.top: parent.top
            // 不在这里参与圆角轮廓，避免与外层重复
            radius: 0
            color: "transparent"
            clip: false

            // 动态流动条（无接缝版本）
            Canvas {
                id: flowFX
                anchors.fill: parent
                antialiasing: true
                renderTarget: Canvas.FramebufferObject

                property real phase
                property real bandWidth: width
                property real dpr: Screen.devicePixelRatio
                onDprChanged: requestPaint()
                onWidthChanged: { requestPaint(); flowAnim.restart() }
                onHeightChanged: requestPaint()

                function colors() {
                    return (theme.gradientColors && theme.gradientColors.length > 0)
                           ? theme.gradientColors
                           : [win.menuGradTop, win.menuGradMid, win.menuGradBot]
                }

                onPaint: {
                    const ctx = getContext("2d");
                    const dpr = Screen.devicePixelRatio;

                    // 用设备像素绘制，避免半像素抖动
                    ctx.resetTransform();
                    ctx.scale(dpr, dpr);

                    const w = width  / dpr;
                    const h = height / dpr;
                    ctx.clearRect(0, 0, w, h);

                    // 圆角裁剪：半径略小 0.5，避免与外层边缘重叠
                    const rr = win.squareCorners ? 0 : Math.max(0, win.cornerRadius - 0.5);
                    if (rr > 0) {
                        ctx.save();
                        const x=0, y=0, ww=w, hh=h, r=Math.min(rr, Math.min(ww,hh)/2);
                        ctx.beginPath();
                        ctx.moveTo(x+r, y);
                        ctx.lineTo(x+ww-r, y);
                        ctx.quadraticCurveTo(x+ww, y, x+ww, y+r);
                        ctx.lineTo(x+ww, y+hh-r);
                        ctx.quadraticCurveTo(x+ww, y+hh, x+ww-r, y+hh);
                        ctx.lineTo(x+r, y+hh);
                        ctx.quadraticCurveTo(x, y+hh, x, y+hh-r);
                        ctx.lineTo(x, y+r);
                        ctx.quadraticCurveTo(x, y, x+r, y);
                        ctx.closePath();
                        ctx.clip();
                    }

                    const bw = bandWidth;
                    if (bw <= 0) { if (rr > 0) ctx.restore(); return; }

                    // 单一渐变 + 画布平移 + 超范围填充（消除白色接缝）
                    const base = colors();
                    const cols = base.slice(0);
                    if (cols.length > 0 && cols[0] !== cols[cols.length - 1]) cols.push(cols[0]);

                    const eps = 0.01;
                    let offset = ((phase % bw) + bw) % bw;
                    if (offset < eps) offset += eps;
                    if (bw - offset < eps) offset -= eps;

                    const g = ctx.createLinearGradient(0, 0, bw, 0);
                    const n = cols.length;
                    for (let i = 0; i < n; ++i) {
                        const t = (n === 1) ? 0.5 : i / (n - 1);
                        g.addColorStop(t, cols[i]);
                    }
                    ctx.fillStyle = g;

                    ctx.save();
                    ctx.translate(-offset, 0);
                    // 左右各多 1px，彻底覆盖边缘
                    ctx.fillRect(-bw - 1, 0, w + bw * 2 + 2, h);
                    ctx.restore();

                    if (rr > 0) ctx.restore();
                }

                onPhaseChanged: requestPaint()

                SequentialAnimation {
                    id: flowAnim
                    loops: Animation.Infinite
                    running: win.visibility !== Window.Hidden
                    NumberAnimation {
                        target: flowFX; property: "phase"
                        // +1 像素，配合 eps，避免循环边界卡在 0
                        from: 0; to: flowFX.bandWidth + 1
                        duration: 9000; easing.type: Easing.Linear
                    }
                }
                Component.onCompleted: flowAnim.start()
            }

            // —— 左侧标题 ——
            Label {
                id: titleText
                text: win.tr("csi.title", "CSI")
                anchors.left: parent.left
                anchors.leftMargin: 14
                anchors.verticalCenter: parent.verticalCenter
                color: win.menuTextColor
                font.pixelSize: 26
                font.weight: Font.DemiBold
                z: 1
            }

            // —— 中部导航 ——
            Row {
                id: navCenter
                spacing: 10
                anchors.verticalCenter: parent.verticalCenter
                anchors.horizontalCenter: parent.horizontalCenter
                z: 1

                ToolButton {
                    id: tabStart
                    text: win.tr("csi.tab.start", "启动")
                    checkable: true
                    checked: win.currentTab === 0
                    padding: 10
                    implicitHeight: 36
                    implicitWidth: Math.max(88, contentItem.implicitWidth + 20)
                    onClicked: win.currentTab = 0
                    scale: pressed ? 0.98 : 1.0
                    Behavior on scale { NumberAnimation { duration: win.durFast; easing.type: Easing.OutCubic } }
                    background: Rectangle { radius: 8; color: tabStart.checked ? win.invertBase : (tabStart.hovered ? win.hoverMask : "transparent") }
                    contentItem: Label { text: tabStart.text; font.pixelSize: 15; color: tabStart.checked ? win.menuGradTop : win.menuTextColor; horizontalAlignment: Text.AlignHCenter; verticalAlignment: Text.AlignVCenter }
                    Accessible.name: tabStart.text
                    Accessible.role: Accessible.Button
                }

                ToolButton {
                    id: tabSettings
                    text: win.tr("csi.tab.settings", "设置")
                    checkable: true
                    checked: win.currentTab === 1
                    padding: 10
                    implicitHeight: 36
                    implicitWidth: Math.max(88, contentItem.implicitWidth + 20)
                    onClicked: win.currentTab = 1
                    scale: pressed ? 0.98 : 1.0
                    Behavior on scale { NumberAnimation { duration: win.durFast; easing.type: Easing.OutCubic } }
                    background: Rectangle { radius: 8; color: tabSettings.checked ? win.invertBase : (tabSettings.hovered ? win.hoverMask : "transparent") }
                    contentItem: Label { text: tabSettings.text; font.pixelSize: 15; color: tabSettings.checked ? win.menuGradTop : win.menuTextColor; horizontalAlignment: Text.AlignHCenter; verticalAlignment: Text.AlignVCenter }
                    Accessible.name: tabSettings.text
                    Accessible.role: Accessible.Button
                }
            }

            // —— 右侧窗口控制 ——
            Row {
                id: rowControls
                spacing: 6
                anchors.right: parent.right
                anchors.rightMargin: 6
                anchors.verticalCenter: parent.verticalCenter
                z: 1

                readonly property string iconMin:  "qrc:/res/icon/window/min.svg"
                readonly property string iconMax:  "qrc:/res/icon/window/max.svg"
                readonly property string iconRes:  "qrc:/res/icon/window/restore.svg"
                readonly property string iconClose:"qrc:/res/icon/window/close.svg"

                ToolButton {
                    id: btnMin
                    implicitWidth: 36; implicitHeight: 28
                    onClicked: win.showMinimized()
                    background: Rectangle { radius: 6; color: btnMin.hovered ? win.hoverMask : "transparent" }
                    contentItem: Image {
                        source: rowControls.iconMin
                        fillMode: Image.PreserveAspectFit
                        anchors.centerIn: parent; width: 14; height: 14
                    }
                    Accessible.name: win.tr("csi.window.minimize", "最小化")
                    Accessible.role: Accessible.Button
                }
                ToolButton {
                    id: btnMax
                    implicitWidth: 36; implicitHeight: 28
                    onClicked: win._debouncedToggleMaxRestore()
                    background: Rectangle { radius: 6; color: btnMax.hovered ? win.hoverMask : "transparent" }
                    contentItem: Image {
                        source: win.squareCorners ? rowControls.iconRes : rowControls.iconMax
                        fillMode: Image.PreserveAspectFit
                        anchors.centerIn: parent; width: 14; height: 14
                    }
                    Accessible.name: win.squareCorners ? win.tr("csi.window.restore", "还原") : win.tr("csi.window.maximize", "最大化")
                    Accessible.role: Accessible.Button
                }
                ToolButton {
                    id: btnClose
                    implicitWidth: 36; implicitHeight: 28
                    onClicked: win.close()
                    background: Rectangle { radius: 6; color: btnClose.hovered ? "#e5484d" : "transparent" }
                    contentItem: Image {
                        source: rowControls.iconClose
                        fillMode: Image.PreserveAspectFit
                        anchors.centerIn: parent; width: 14; height: 14
                    }
                    Accessible.name: win.tr("csi.window.close", "关闭")
                    Accessible.role: Accessible.Button
                }
            }

            DragHandler { target: null; onActiveChanged: if (active) win.startSystemMove() }
            TapHandler  { gesturePolicy: TapHandler.DragThreshold; onDoubleTapped: win._debouncedToggleMaxRestore() }
        }

        // ===== 内容区 =====
        StackLayout {
            id: stack
            anchors.left: parent.left; anchors.right: parent.right
            anchors.top: titleBar.bottom; anchors.bottom: parent.bottom
            currentIndex: win.currentTab

            Loader {
                id: startPage
                source: "qrc:/res/qml/pages/StartPage.qml"
                asynchronous: true
                active: stack.currentIndex === 0
            }
            Loader {
                id: settingsPage
                source: "qrc:/res/qml/pages/SettingsPage.qml"
                asynchronous: true
                active: stack.currentIndex === 1
            }
        }
    }

    // ===== 系统级缩放边缘 =====
    Rectangle { anchors { left: parent.left; right: parent.right; top: parent.top } height: win.hit; color: "transparent"; visible: !win.squareCorners; HoverHandler { cursorShape: Qt.SizeVerCursor } DragHandler { target: null; grabPermissions: PointerHandler.CanTakeOverFromAnything; onActiveChanged: if (active) win.startSystemResize(Qt.TopEdge) } }
    Rectangle { anchors { left: parent.left; right: parent.right; bottom: parent.bottom } height: win.hit; color: "transparent"; visible: !win.squareCorners; HoverHandler { cursorShape: Qt.SizeVerCursor } DragHandler { target: null; grabPermissions: PointerHandler.CanTakeOverFromAnything; onActiveChanged: if (active) win.startSystemResize(Qt.BottomEdge) } }
    Rectangle { anchors { top: parent.top; bottom: parent.bottom; left: parent.left } width: win.hit; color: "transparent"; visible: !win.squareCorners; HoverHandler { cursorShape: Qt.SizeHorCursor } DragHandler { target: null; grabPermissions: PointerHandler.CanTakeOverFromAnything; onActiveChanged: if (active) win.startSystemResize(Qt.LeftEdge) } }
    Rectangle { anchors { top: parent.top; bottom: parent.bottom; right: parent.right } width: win.hit; color: "transparent"; visible: !win.squareCorners; HoverHandler { cursorShape: Qt.SizeHorCursor } DragHandler { target: null; grabPermissions: PointerHandler.CanTakeOverFromAnything; onActiveChanged: if (active) win.startSystemResize(Qt.RightEdge) } }

    /* ===== 四个角 ===== */
    Rectangle { x: 0; y: 0; width: win.cornerHit; height: win.cornerHit; color: "transparent"; visible: !win.squareCorners; HoverHandler { cursorShape: Qt.SizeFDiagCursor } DragHandler { target: null; onActiveChanged: if (active) win.startSystemResize(Qt.TopEdge | Qt.LeftEdge) } }
    Rectangle { anchors.right: parent.right; y: 0; width: win.cornerHit; height: win.cornerHit; color: "transparent"; visible: !win.squareCorners; HoverHandler { cursorShape: Qt.SizeBDiagCursor } DragHandler { target: null; onActiveChanged: if (active) win.startSystemResize(Qt.TopEdge | Qt.RightEdge) } }
    Rectangle { x: 0; anchors.bottom: parent.bottom; width: win.cornerHit; height: win.cornerHit; color: "transparent"; visible: !win.squareCorners; HoverHandler { cursorShape: Qt.SizeBDiagCursor } DragHandler { target: null; onActiveChanged: if (active) win.startSystemResize(Qt.BottomEdge | Qt.LeftEdge) } }
    Rectangle { anchors.right: parent.right; anchors.bottom: parent.bottom; width: win.cornerHit; height: win.cornerHit; color: "transparent"; visible: !win.squareCorners; HoverHandler { cursorShape: Qt.SizeFDiagCursor } DragHandler { target: null; onActiveChanged: if (active) win.startSystemResize(Qt.BottomEdge | Qt.RightEdge) } }
}
