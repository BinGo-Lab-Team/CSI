pragma ComponentBehavior: Bound
import QtQuick
import QtQuick.Controls
import QtQuick.Layouts
import QtMultimedia

// ==== 程序窗口 ====
ApplicationWindow {
    id: win
    visible: true
    width: 960
    height: 640
    title: win.tr("csi.title", "CSI")
    color: "transparent"
    flags: Qt.Window | Qt.FramelessWindowHint

    // ―― 监听可见性变化（使用 Connections 显式形参，避免隐式注入弃用警告） ――
    Connections {
        target: win
        function onVisibilityChanged(newVis) {
            if ((win._lastVis === Window.AutomaticVisibility || win._lastVis === Window.Windowed) && (newVis === Window.Maximized || newVis === Window.FullScreen)) {
                win._recordNormalGeom();
            }
            win._lastVis = newVis;
        }
    }

    // ===== 配置 =====
    readonly property bool maximized: visibility === Window.Maximized
    readonly property bool squareCorners: (visibility === Window.FullScreen) || (visibility === Window.Maximized)
    property int currentTab: 0
    property int cornerRadius: 12
    property int inset: 18

    // ―― 还原时需要的上一次“普通窗口”几何 ――
    property int lastNormalX: 100
    property int lastNormalY: 100
    property int lastNormalWidth: 960
    property int lastNormalHeight: 640
    property int _lastVis: Window.AutomaticVisibility
    function _recordNormalGeom() {
        if (visibility === Window.AutomaticVisibility || visibility === Window.Windowed) {
            lastNormalX = win.x;
            lastNormalY = win.y;
            lastNormalWidth = win.width;
            lastNormalHeight = win.height;
        }
    }

    readonly property int durFast: 80
    readonly property int durMed: 120
    readonly property int durSlow: 160
    readonly property int debounceMs: 200
    property double _lastToggleTS: 0
    function _now() {
        return Date.now();
    }
    function _debouncedToggleMaxRestore() {
        var t = _now();
        if (t - _lastToggleTS < debounceMs)
            return;
        _lastToggleTS = t;
        if (!maximized) {
            _recordNormalGeom();
            win.showMaximized();
        } else {
            win.showNormal();
        }
    }

    readonly property real dpr: Screen.devicePixelRatio
    readonly property int hit: Math.round(6 * dpr)
    readonly property int cornerHit: Math.round(10 * dpr)

    // 播放启动音乐
    property bool enableStartupSound: true
    MediaPlayer {
        id: startupPlayer
        source: "qrc:/res/audio/startup.wav"
        audioOutput: AudioOutput {
            id: out
            volume: 1.0
            muted: false
        }
        Component.onCompleted: Qt.callLater(() => {
            if (win.enableStartupSound)
                play();
        })
        onErrorOccurred: (error, errorString) => {
            console.warn("[MediaPlayer] error:", error, errorString);
            win.enableStartupSound = false;
        }
    }

    // ==== 主题 ====
    Theme {
        id: theme
    }
    property color menuGradTop: theme.menuGradTop
    property color menuGradMid: theme.menuGradMid
    property color menuGradBot: theme.menuGradBot
    property color menuTextColor: theme.menuTextColor
    property color hoverMask: theme.hoverMask
    readonly property color invertBase: menuTextColor

    function tr(id, fallback) {
        var s = qsTrId(id);
        return (s === id || s === "") ? fallback : s;
    }

    // ==== 快捷键 ====
    Shortcut {
        sequences: [StandardKey.Close]
        onActivated: win.close()
    }
    Shortcut {
        sequences: ["Alt+F10"]
        onActivated: win._debouncedToggleMaxRestore()
    }
    Shortcut {
        sequences: ["F11"]
        onActivated: win.visibility = (win.visibility === Window.FullScreen) ? Window.AutomaticVisibility : Window.FullScreen
    }
    Shortcut {
        sequences: ["Escape"]
        onActivated: if (win.visibility === Window.FullScreen)
            win.showNormal()
    }
    Shortcut {
        sequences: ["Ctrl+1"]
        onActivated: win.currentTab = 0
    }
    Shortcut {
        sequences: ["Ctrl+2"]
        onActivated: win.currentTab = 1
    }

    // ==== 窗口 ====
    ShadowFrame {
        id: shell
        anchors.fill: parent
        inset: win.squareCorners ? 0 : win.inset
        cornerRadius: win.cornerRadius
        squareCorners: win.squareCorners
        frameColor: win.palette.window

        // ===== 标题栏 =====
        Rectangle {
            id: titleBar
            height: 56
            anchors.left: parent.left
            anchors.right: parent.right
            anchors.top: parent.top
            radius: win.squareCorners ? 0 : win.cornerRadius
            color: "transparent"
            clip: false

            // ―― 无缝流动条 ――
            Canvas {
                id: flowFX
                anchors.fill: parent
                anchors.margins: -1                  // 外扩 1px 盖住 AA 边缘
                antialiasing: true
                renderTarget: Canvas.FramebufferObject

                property real phase: 0
                property real bandWidth: width

                onWidthChanged: {
                    requestPaint();
                    flowAnim.restart();
                }
                onHeightChanged: requestPaint()
                onPhaseChanged: requestPaint()

                function colors() {
                    return (theme.gradientColors && theme.gradientColors.length > 0) ? theme.gradientColors : [win.menuGradTop, win.menuGradMid, win.menuGradBot];
                }

                onPaint: {
                    const ctx = getContext("2d");
                    const dpr = Screen.devicePixelRatio;

                    ctx.resetTransform();
                    ctx.scale(dpr, dpr);

                    const w = width / dpr;
                    const h = height / dpr;
                    ctx.clearRect(-2, -2, w + 4, h + 4);

                    // 只做“上边两圆角”
                    const R0 = win.squareCorners ? 0 : win.cornerRadius;
                    const bleed = 1 / dpr;                                  // 与 -1 margin 对齐
                    const x = -bleed, y = -bleed;                           // 外扩几何
                    const ww = w + 2 * bleed, hh = h + 2 * bleed;
                    const r = Math.min(R0 + bleed, Math.min(ww, hh) / 2);

                    if (r > 0) {
                        ctx.save();
                        ctx.beginPath();

                        // 从左边缘的“上圆角下切点”开始
                        ctx.moveTo(x, y + r);

                        // 左上角（更饱满的二次贝塞尔）
                        ctx.quadraticCurveTo(x, y, x + r, y);

                        // 顶边到右上角
                        ctx.lineTo(x + ww - r, y);
                        ctx.quadraticCurveTo(x + ww, y, x + ww, y + r);

                        // 右边直下到底（下角直角）
                        ctx.lineTo(x + ww, y + hh);

                        // 底边直线回到左下（下角直角）
                        ctx.lineTo(x, y + hh);

                        // 左边直上回到起点
                        ctx.lineTo(x, y + r);

                        ctx.closePath();
                        ctx.clip();
                    }

                    // ―― 条带绘制：像素对齐 + 左右 ±1px 重叠（无缝）――
                    const bw = bandWidth;
                    if (bw > 0) {
                        const base = colors();
                        const cols = base.slice(0);
                        if (cols.length && cols[0] !== cols[cols.length - 1])
                            cols.push(cols[0]);

                        let offset = ((phase % bw) + bw) % bw;
                        let startX = -offset - bw;

                        while (startX < w + bw) {
                            const xi = Math.round(startX);                  // 设备像素对齐
                            const g = ctx.createLinearGradient(xi, 0, xi + bw, 0);
                            const n = cols.length;
                            for (let i = 0; i < n; ++i) {
                                const t = (n === 1) ? 0.5 : i / (n - 1);
                                g.addColorStop(t, cols[i]);
                            }
                            ctx.fillStyle = g;
                            ctx.fillRect(xi - 1, 0, bw + 2, h);            // 左右各重叠 1px
                            startX += bw;
                        }
                    }

                    if (r > 0)
                        ctx.restore();
                }

                SequentialAnimation {
                    id: flowAnim
                    loops: Animation.Infinite
                    running: win.visibility !== Window.Hidden
                    NumberAnimation {
                        target: flowFX
                        property: "phase"
                        from: 0
                        to: flowFX.bandWidth
                        duration: 9000
                        easing.type: Easing.Linear
                    }
                }
            }

            // ―― 左侧标题 ――
            Label {
                id: titleText
                text: win.tr("csi.title", "CSI")
                anchors.left: parent.left
                anchors.leftMargin: 14
                anchors.verticalCenter: parent.verticalCenter
                color: win.menuTextColor
                font.pixelSize: 26
                font.weight: Font.DemiBold
                z: 1
            }

            // ―― 中部导航 ――
            Row {
                id: navCenter
                spacing: 10
                anchors.verticalCenter: parent.verticalCenter
                anchors.horizontalCenter: parent.horizontalCenter
                z: 1

                ToolButton {
                    id: tabStart
                    text: win.tr("csi.tab.start", "启动")
                    checkable: true
                    checked: win.currentTab === 0
                    padding: 10
                    implicitHeight: 36
                    implicitWidth: Math.max(88, contentItem.implicitWidth + 20)
                    onClicked: win.currentTab = 0
                    scale: pressed ? 0.98 : 1.0
                    Behavior on scale {
                        NumberAnimation {
                            duration: win.durFast
                            easing.type: Easing.OutCubic
                        }
                    }
                    background: Rectangle {
                        radius: 8
                        color: tabStart.checked ? win.invertBase : (tabStart.hovered ? win.hoverMask : "transparent")
                    }
                    contentItem: Label {
                        text: tabStart.text
                        font.pixelSize: 15
                        color: tabStart.checked ? win.menuGradTop : win.menuTextColor
                        horizontalAlignment: Text.AlignHCenter
                        verticalAlignment: Text.AlignVCenter
                    }
                    Accessible.name: tabStart.text
                    Accessible.role: Accessible.Button
                }

                ToolButton {
                    id: tabSettings
                    text: win.tr("csi.tab.settings", "设置")
                    checkable: true
                    checked: win.currentTab === 1
                    padding: 10
                    implicitHeight: 36
                    implicitWidth: Math.max(88, contentItem.implicitWidth + 20)
                    onClicked: win.currentTab = 1
                    scale: pressed ? 0.98 : 1.0
                    Behavior on scale {
                        NumberAnimation {
                            duration: win.durFast
                            easing.type: Easing.OutCubic
                        }
                    }
                    background: Rectangle {
                        radius: 8
                        color: tabSettings.checked ? win.invertBase : (tabSettings.hovered ? win.hoverMask : "transparent")
                    }
                    contentItem: Label {
                        text: tabSettings.text
                        font.pixelSize: 15
                        color: tabSettings.checked ? win.menuGradTop : win.menuTextColor
                        horizontalAlignment: Text.AlignHCenter
                        verticalAlignment: Text.AlignVCenter
                    }
                    Accessible.name: tabSettings.text
                    Accessible.role: Accessible.Button
                }
            }

            // ―― 右侧窗口控制 ――
            Row {
                id: rowControls
                spacing: 6
                anchors.right: parent.right
                anchors.rightMargin: 6
                anchors.verticalCenter: parent.verticalCenter
                z: 1

                readonly property string iconMin: "qrc:/res/icon/window/min.svg"
                readonly property string iconMax: "qrc:/res/icon/window/max.svg"
                readonly property string iconRes: "qrc:/res/icon/window/restore.svg"
                readonly property string iconClose: "qrc:/res/icon/window/close.svg"

                ToolButton {
                    id: btnMin
                    implicitWidth: 36
                    implicitHeight: 28
                    onClicked: win.showMinimized()
                    background: Rectangle {
                        radius: 6
                        color: btnMin.hovered ? win.hoverMask : "transparent"
                    }
                    contentItem: Image {
                        source: rowControls.iconMin
                        fillMode: Image.PreserveAspectFit
                        anchors.centerIn: parent
                        width: 14
                        height: 14
                    }
                    Accessible.name: win.tr("csi.window.minimize", "最小化")
                    Accessible.role: Accessible.Button
                }
                ToolButton {
                    id: btnMax
                    implicitWidth: 36
                    implicitHeight: 28
                    onClicked: win._debouncedToggleMaxRestore()
                    background: Rectangle {
                        radius: 6
                        color: btnMax.hovered ? win.hoverMask : "transparent"
                    }
                    contentItem: Image {
                        source: win.squareCorners ? rowControls.iconRes : rowControls.iconMax
                        fillMode: Image.PreserveAspectFit
                        anchors.centerIn: parent
                        width: 14
                        height: 14
                    }
                    Accessible.name: win.squareCorners ? win.tr("csi.window.restore", "还原") : win.tr("csi.window.maximize", "最大化")
                    Accessible.role: Accessible.Button
                }
                ToolButton {
                    id: btnClose
                    implicitWidth: 36
                    implicitHeight: 28
                    onClicked: win.close()
                    background: Rectangle {
                        radius: 6
                        color: btnClose.hovered ? "#e5484d" : "transparent"
                    }
                    contentItem: Image {
                        source: rowControls.iconClose
                        fillMode: Image.PreserveAspectFit
                        anchors.centerIn: parent
                        width: 14
                        height: 14
                    }
                    Accessible.name: win.tr("csi.window.close", "关闭")
                    Accessible.role: Accessible.Button
                }
            }

            DragHandler {
                id: dragTitle
                target: null
                grabPermissions: PointerHandler.CanTakeOverFromAnything
                onActiveChanged: if (active) {
                    const p = dragTitle.centroid.scenePosition;

                    function relayoutAndDrag() {
                        // 以鼠标为锚点计算新位置，尽量减少“跳点”感
                        var w = Math.max(400, lastNormalWidth);
                        var h = Math.max(300, lastNormalHeight);
                        var offX = Math.max(0, Math.min(w, p.x - win.x));
                        var offY = Math.max(0, Math.min(h, p.y - win.y));
                        var nx = Math.round(p.x - offX);
                        var ny = Math.round(p.y - Math.min(offY, titleBar.height));
                        ny = Math.max(0, ny);
                        win.x = nx;
                        win.y = ny;
                        win.width = w;
                        win.height = h;
                        // 还原后一帧再进入系统拖动，更稳
                        Qt.callLater(() => {
                            if (flowAnim)
                                flowAnim.running = true;
                            win.startSystemMove();
                        });
                    }

                    if (win.visibility === Window.FullScreen || win.maximized) {
                        // 先暂停标题栏动画，减小重绘压力
                        if (flowAnim)
                            flowAnim.running = false;
                        win.showNormal();
                        Qt.callLater(relayoutAndDrag);
                    } else {
                        win.startSystemMove();
                    }
                }
            }
            TapHandler {
                gesturePolicy: TapHandler.DragThreshold
                onDoubleTapped: win._debouncedToggleMaxRestore()
            }
        }

        // ===== 内容区 =====
        StackLayout {
            id: stack
            anchors.left: parent.left
            anchors.right: parent.right
            anchors.top: titleBar.bottom
            anchors.bottom: parent.bottom
            currentIndex: win.currentTab

            Loader {
                id: startPage
                source: "qrc:/res/qml/pages/StartPage.qml"
                asynchronous: true
                active: stack.currentIndex === 0
            }
            Loader {
                id: settingsPage
                source: "qrc:/res/qml/pages/SettingsPage.qml"
                asynchronous: true
                active: stack.currentIndex === 1
            }
        }
    }

    // ===== 缩放边缘 =====
    Rectangle {
        anchors {
            left: parent.left
            right: parent.right
            top: parent.top
        }
        height: win.hit
        color: "transparent"
        visible: !win.squareCorners
        HoverHandler {
            cursorShape: Qt.SizeVerCursor
        }
        DragHandler {
            target: null
            grabPermissions: PointerHandler.CanTakeOverFromAnything
            onActiveChanged: if (active)
                win.startSystemResize(Qt.TopEdge)
        }
    }
    Rectangle {
        anchors {
            left: parent.left
            right: parent.right
            bottom: parent.bottom
        }
        height: win.hit
        color: "transparent"
        visible: !win.squareCorners
        HoverHandler {
            cursorShape: Qt.SizeVerCursor
        }
        DragHandler {
            target: null
            grabPermissions: PointerHandler.CanTakeOverFromAnything
            onActiveChanged: if (active)
                win.startSystemResize(Qt.BottomEdge)
        }
    }
    Rectangle {
        anchors {
            top: parent.top
            bottom: parent.bottom
            left: parent.left
        }
        width: win.hit
        color: "transparent"
        visible: !win.squareCorners
        HoverHandler {
            cursorShape: Qt.SizeHorCursor
        }
        DragHandler {
            target: null
            grabPermissions: PointerHandler.CanTakeOverFromAnything
            onActiveChanged: if (active)
                win.startSystemResize(Qt.LeftEdge)
        }
    }
    Rectangle {
        anchors {
            top: parent.top
            bottom: parent.bottom
            right: parent.right
        }
        width: win.hit
        color: "transparent"
        visible: !win.squareCorners
        HoverHandler {
            cursorShape: Qt.SizeHorCursor
        }
        DragHandler {
            target: null
            grabPermissions: PointerHandler.CanTakeOverFromAnything
            onActiveChanged: if (active)
                win.startSystemResize(Qt.RightEdge)
        }
    }

    // ===== 四个角 =====
    Rectangle {
        x: 0
        y: 0
        width: win.cornerHit
        height: win.cornerHit
        color: "transparent"
        visible: !win.squareCorners
        HoverHandler {
            cursorShape: Qt.SizeFDiagCursor
        }
        DragHandler {
            target: null
            onActiveChanged: if (active)
                win.startSystemResize(Qt.TopEdge | Qt.LeftEdge)
        }
    }
    Rectangle {
        anchors.right: parent.right
        y: 0
        width: win.cornerHit
        height: win.cornerHit
        color: "transparent"
        visible: !win.squareCorners
        HoverHandler {
            cursorShape: Qt.SizeBDiagCursor
        }
        DragHandler {
            target: null
            onActiveChanged: if (active)
                win.startSystemResize(Qt.TopEdge | Qt.RightEdge)
        }
    }
    Rectangle {
        x: 0
        anchors.bottom: parent.bottom
        width: win.cornerHit
        height: win.cornerHit
        color: "transparent"
        visible: !win.squareCorners
        HoverHandler {
            cursorShape: Qt.SizeBDiagCursor
        }
        DragHandler {
            target: null
            onActiveChanged: if (active)
                win.startSystemResize(Qt.BottomEdge | Qt.LeftEdge)
        }
    }
    Rectangle {
        anchors.right: parent.right
        anchors.bottom: parent.bottom
        width: win.cornerHit
        height: win.cornerHit
        color: "transparent"
        visible: !win.squareCorners
        HoverHandler {
            cursorShape: Qt.SizeFDiagCursor
        }
        DragHandler {
            target: null
            onActiveChanged: if (active)
                win.startSystemResize(Qt.BottomEdge | Qt.RightEdge)
        }
    }
}
